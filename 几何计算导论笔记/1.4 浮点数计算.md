# 浮点数计算

如前所述，计算机并不能精确地表示实数，这是因为存储实数的位数是有限的。因此，任何具有无限位数的实数如$1/3$、2的平方根和$\pi$，都不能完全精确的在计算机中表示。此外，由于实数的编码方式，即便是有限位数也不能精确表示。

我们知道十进制下0.1转变成二进制表示为0.00011000110001100011.....，转换为十六进制则表示为0.199999999.....。即便这已经是一个十分简单的十进制实数，但是我们观察到其转换成二进制或十六进制时仍是一个无限位数的数。很显然使用计算机中最常见的二进制和十六进制编码浮点数的方法无法精确地表示十进制下的0.1。这是一个我们不得不面对的、无法改变的——除非我们创造出了10进制计算机——问题。

### 精度丢失

在计算中更重要的问题是丢失有效数字——即精度丢失，尤其在减法计算中。何为精度丢失？假设我们有一台十进制计算机，其可以存储4位有效数字。当将0.1234和0.9999相加时，精确结果为1.1233，然而因为该计算机只能存储4位有效数字，该精确结果要么被四舍五入要么直接截断，以使得仅有四位有效数字保留。因此，在计算机中该结果为1.123。类似地，乘法和除法也是如此。

再来考虑减法。当我们用0.1235减去0.1234时，其精确结果为0.0001。0.1234和0.1235都有着4位有效数字，在做减法操作之后结果0.0001却仅有1位有效数字！也就是说我们仅有一位可以信任的数字，在随后的计算中，比如说0.0001加上0.1236，因为前者仅有一位可信任数字，所以得到的结果仅有一位可靠数字！因此，减法会导致有效数字的丢失，因此我们应该尽可能避免做减法操作。

> 注意：计算机中浮点数以指数形式存储，如0.0012345存储为$0.12345×10^{-2}$，12.345存储为$0.12345×10^2$。假设我们在一台仅能存储三位有效数字的计算机上将两个浮点数0.0123和12.3相加，总和为112.3123，其将会被存储为$0.123×10^2$。类似地，假设在仅能存储四位有效数字的计算机上将0.1235减去0.1234，结果为0.0001，其将会被存储为$0.1×10^{-3}$且仅有一位有效数字。

### 例1

我们一起看一个熟悉例子，解下面的二次方程：

![img](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/overview/quad-1.jpg)

由其求根公式我们知道

![img](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/overview/root-1.jpg)

如果我们将$a=1,b=-20000,c=1$代入，则单精度下得到根为20000和0。这是不正确的，因为根的乘积根据韦达定理应该为$c/a=1$，显然这是非0的。那么问题出在哪里呢？在上述情况中，当b的值很大，而a、c的值很小时，$b^2-4ac$的值几乎等于b的平方，因此，该值的平方根与-b的和为0。

虽然我们无法消除平方根下面的减法操作，但是我们可以做一些改善，如下面方法所见：

1.将根乘以

![img](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/overview/factor.jpg)

这将会把根变为

![img](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/overview/root-2.jpg)

如果b为正，则分母为加法操作，即将两个正数相加，减法操作得以隐式消除，此时根为

![img](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/overview/1st-root-1.jpg)

如果b为负，则分母为减法操作，实际上效果为两个负数相加，减法操作也得以消除。

因为两个根的乘积为$c/a$所以我们得到一个根之后，只需要除以$c/a$即可以得到另一个根，根据此法得到结果为20000和0.00005。

但此时结果正确么？未必。因为根据韦达定理我们知道两根之和应该为$-b/a=20000$，而此时两根之和并非如此。然而问题不大，由于单精度通常提供七位有效数字，因此20000和0.00005之和20000.00005，将会被存储为$0.2000000×10^5$，正好0.00005被舍入或者截断。

2.第二种方法中，我们首先将给定的方程归一化，也即我们将给定方程的形式变换为如下

![img](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/overview/quad-2.jpg)

其中$p=b/(2a)$且$q=c/a$，此时由求根公式得

![img](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/overview/root-3.jpg)

与上面方法类似，如果$p$为正，$-p$为负，此时进行减法，实际上效果为两负数之和，此时其一根为

![img](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/overview/1st-root-2.jpg)

如果$p$为负，$-p$为正，此时进行加法...

类似地，在得到两根其一后，我们仅需将其除以$q$，即可得另一根。计算得根为20000和0.00005,与第一种方法相同。

### 例2

使用无穷级数求解$sin$函数，即

![img](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/overview/sinx.jpg)

看到上面的级数，我们不免头疼，因为存在许多减法操作。如下编写正弦函数：

```
float MySin(float x){
	float sinx=0.0;
	float term=x;
	float sign=1.0;
	float denom=1.0;
	
	while(fabs(term)>=EPSILON){
		sinx=sinx+sign*term;
		term=term*x/(++denom);
		term=term*x/(++denom);
		sign=-sign
	}
	return sinx;
}
```

将EPSILON设置为$1.0E-8$，当x为-30、-25、-20....、20、25和30时，结果为：

```
 x             MySin          sin(x)
---            -----          ------
-30.000000     33002.515625   0.988032
-25.000000     270.567413     0.132352
-20.000000     -0.957176      -0.912945
-15.000000     -0.677538      -0.650288
-10.000000     0.544120       0.544021
-5.000000      0.958925       0.958924
0.000000       0.000000       0.000000
5.000000       -0.958925      -0.958924
10.000000      -0.544120      -0.544021
15.000000      0.677538       0.650288
20.000000      0.957176       0.912945
25.000000      -270.567413    -0.132352
30.000000      -33002.515625  -0.988032
```

第二列为程序输出，第三列为$sin$库函数结果。可以观察到，当x值越发接近0，程序结果也和真实结果越发一致；而当x值越大，精度丢失问题越发严重以至于结果甚至不在[0,1]范围内。注：$sin$库函数使用其他方法计算正弦值。

单击[此处](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/overview/sin.c)下载此示例的C程序。您可能想尝试将所有正项和负项先相加起来，然后统一做一次减法操作来获得结果。将您的结果与上面的坏结果进行比较，你得到了什么？

### 数学定律有时也不适用于有限精度计算

注意我们所熟悉的数学定律有时并不适用于有限精度计算，这需要我们仔细选择表达式的计算顺序，接下来我们将仅讨论交换律和结合律。

交换律即是对于加法和乘法运算，$a*b$和$b*a$的结果在数学上是相同的。在计算机中运用此规律则需要十分注意，考虑计算$a*b*c$，其中a和c是非常大的数字，b非常小，且$a*b$和$b*c$接近于1，此时计算$a*b*c$非常简单。

现在我们尝试使用交换律，将上述表达式表示为$a*c*b$，这将会造成溢出问题，因为$a*c$太大了导致硬件无法表示！

结合律即$(a*b)*c$或者$a*(b*c)$来表示$a*b*c$，虽然数学上成立但计算中可能有很大问题。考虑下面的几个完全等价的递归表达式：

![img](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/overview/assoc.jpg)

我们可以将$R=3.0$以及初始值$x=0.5$代入。这五个式子在数学上是等价的，然而当我们计算到$x_{1000}$并且每100项打印出来，会发现如下结果：

```
    0           0.5           0.5           0.5           0.5           0.5
  100    1.6782e-05       1.30277      0.506627       1.14111      0.355481
  200       1.28383       0.97182       1.25677       1.04532      0.805295
  300      0.745989      0.155282       1.32845      0.295785     0.0590719
  400     0.0744125      0.354702       1.00514      0.882786      0.171617
  500      0.788592    0.00176679      0.804004      0.496569       1.32348
  600     0.0190271       0.35197      0.832942      0.518201       1.20776
  700      0.377182      0.525322       0.31786      0.435079      0.525364
  800        0.1293   0.000277146       1.33159     0.0130949      0.954542
  900      0.375104    0.00743761       1.27548      0.409476    0.00996984
 1000      0.680855       1.03939      0.462035     0.0734742       1.26296
```

使用了结合律的所有五种方法都得出了完全不同的结果而且在第100项时就已然很大不同。单击[此处](https://pages.mtu.edu/~shene/COURSES/cs3621/NOTES/overview/assoc.c)下载此示例的C程序。